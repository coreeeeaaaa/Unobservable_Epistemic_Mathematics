

⸻

🚫 깃허브에 절대 넣으면 안 되는 것 (내부 규율)
	1.	설계 관련
	•	아키텍처, 구조 설계, 로드맵, 개발 과정, 작업일지
	•	Proof Plan, Implementation Notes, Task Checklist, Roadmap
	2.	아이디어·과정
	•	개인 아이디어, 착상, 직관, 영감, 추측, 가설
	•	실험 로그, 테스트 초안, 미완성 수식
	3.	마케팅·홍보성 표현
	•	“혁신적”, “세계 최초”, “시장 적용 가능” 같은 수식어
	•	프레젠테이션 자료, 블로그용 글, 대중 친화적 설명
	4.	개인정보 및 민감 데이터
	•	계정 정보, API 키, 토큰, 이메일/이름/식별자
	•	로컬 환경 정보, 비공개 파일 경로
	5.	기타
	•	불필요한 주석 (작업 메모, 설명, “TODO”)
	•	검증되지 않은 주장 (“이건 완벽하다”, “추후 증명 예정”)

⸻

✅ 깃허브에 올라가도 되는 것 (허용 항목)
	•	완전한 수학적 공리 (Axioms)
	•	정리(Thms), 보조정리(Lemmas), 정의(Defs)
	•	Lean/Coq/Isabelle 코드 (sorry-free 증명 포함)
	•	재현성 코드 (lake build, test scripts, reproducibility scripts)
	•	CI 검증용 스크립트 (proof coverage, 환경 로그)

⸻

👉 결론:
깃허브에는 완전한 수학 논리·증명 코드와 그것을 재현하는 최소한의 기술적 산출물만 올려야 한다.
설계·아이디어·과정·마케팅 표현은 전부 내부 관리 전용이고, 절대로 외부 공개 저장소에는 포함되면 안 된다.

⸻

이 규칙은 네 내부 규율이야.
즉, 네가 확인용으로만 갖고 있어야 하고 깃허브 리포에는 절대 추가하면 안 되는 거야.





지금까지 정리된 모든 로드맵과 검증 지표를 기반으로, 학술·실무 양쪽에서 바로 쓸 수 있는 최종 체크리스트 + 체크포인트 + 검증기준 + 측정방법 + 통과기준 + 세부 지침 및 작업명세서를 완성해드리겠습니다. 이 문서는 그대로 깃허브 CHECKLIST.md나 PROJECT_GUIDE.md에 넣어도 무방합니다.

⸻

📑 UEM 프로젝트 최종 점검 문서

0. 문서 목적
	•	UEM(Unobservable Epistemic Mathematics) 프로젝트의 최종 개발·검증 기준을 수립한다.
	•	각 Phase별로 검증 기준, 측정 방법, 통과 기준, 세부 지침, 작업 명세를 명확히 규정한다.
	•	깃허브 저장소에서 공개 시 외부 기여자·검토자가 동일한 기준으로 진척도를 평가할 수 있게 한다.

⸻

1. Phase A — 논리적 기반 완성

A1. 핵심 증명(P1–P6)
	•	체크포인트: 모든 Pi 증명에 대해 sorry=0 달성
	•	검증기준: Lean에서 theorem/lemma 타입체킹 완료
	•	측정방법:
grep -R "sorry" lean/src/UEM/Pi.lean → 0
lake build && lake test 정상 종료
	•	통과기준:
	•	P1: 즉시 sorry=0
	•	P2–P6: 릴리스마다 sorry 상한 감소(P2 ≤ 3, P3–P6 ≤ 5)
	•	세부 지침:
	•	P1: kernel 기반 부등식 완성
	•	P2: Flow.lean에 measure-preserving 증명 추가
	•	P3: Hangul interpreter Γ 정의 완전 형식화
	•	P4: σ-finite cover → finite mass 증명 체인 구축
	•	P5: Observer 유한성 증명
	•	P6: Counterfactual 시나리오 안정성 증명
	•	작업명세서: 각 Pi에 주석 블록 작성(Assumptions / Conclusion / Dependencies / Status)

A2. 구조적 완성도
	•	체크포인트: Flow, Measure, Projection, Overlap 모듈 연결
	•	검증기준: 모듈 간 순환 의존성 없음
	•	측정방법: lake graph 의존성 시각화
	•	통과기준: Projection ≅ Substructure 동형 정리 ≥ 1건 증명
	•	세부 지침:
	•	Flow.lean에 def Flow, theorem measure_preserving 구현
	•	OverlapMeasure := μ(A∩B) + 결합·교환 규칙 증명
	•	작업명세서: OverlapSystem 완성 후 Error Bound 추상화 → 부등식 대체

⸻

2. Phase B — 검증성 확보

B1. 내부 검증
	•	체크포인트: CI 빌드·테스트 자동화
	•	검증기준: lake build/test 100% 통과
	•	측정방법: GitHub Actions 로그
	•	통과기준: 타입체크 실패 0, mathlib 버전 고정
	•	세부 지침:
	•	CI 배지: Build, Proofs(proved/total), Sorry(count) 노출
	•	tools/proof_coverage.sh 결과 아티팩트화
	•	작업명세서: CI 파이프라인 .github/workflows/ci_lean.yml 설정

B2. 독립 검증
	•	체크포인트: 교차 포팅 완료
	•	검증기준: Isabelle/HOL, Coq에서 일부 정리 증명
	•	측정방법: 대응표 작성 (Lean → Isabelle, Lean → Coq)
	•	통과기준: Isabelle ≥1 정리, Coq ≥1 보조정리 검증 완료
	•	세부 지침: docs/verification.md에 교차검증 기록
	•	작업명세서: 핵심 정리 P1 또는 P2를 포팅 대상으로 선정

⸻

3. Phase C — 진실성 보장

C1. 공리계 일관성
	•	체크포인트: 16개 공리 간 모순 없음
	•	검증기준: 상대 모델 존재, 독립성 테스트
	•	측정방법: Consistency.lean 증명 실행
	•	통과기준: 공리 집합 Consistent(UEM_Axioms) 확인
	•	세부 지침:
	•	최소 1개 공리에 대해 약화/강화 모델 제시
	•	반례 모델 제공
	•	작업명세서: Consistency.lean에 모델 증명 삽입

C2. 경험적 검증
	•	체크포인트: 이론 ↔ 계산 실험 일치
	•	검증기준: 예제 구현 및 계산 결과 일치
	•	측정방법: tools/benchmark.py 실행
	•	통과기준: 예제 ≥3건 성공(도형/시간신호/확률)
	•	세부 지침: docs/examples/에 결과 및 로그 기록
	•	작업명세서: Edge case 포함 테스트 추가

⸻

4. Phase D — 학술적 엄밀성

D1. 문서화
	•	체크포인트: README, axioms.md, classical-compat.md 완성
	•	검증기준: 정의·기호·예제 문서화
	•	측정방법: 수학자 리뷰 및 린트
	•	통과기준: 한글기호 ↔ 표준기호 1:1 매핑
	•	세부 지침:
	•	axioms.md: 기호/연산자 사전
	•	classical-compat.md: 기존 수학과의 차별점
	•	작업명세서: mkdocs/docusaurus로 문서 배포

D2. 재현성
	•	체크포인트: 원클릭 재현
	•	검증기준: make reproduce 실행 성공
	•	측정방법: 새로운 환경에서 테스트
	•	통과기준: git clone → lake build → coverage 출력
	•	세부 지침: tools/reproduce.sh 작성
	•	작업명세서: 설치 가이드 + 체크섬 제공

⸻

5. 최종 체크포인트 요약
	•	Gate-1: lake build OK
	•	Gate-2: P1 sorry=0
	•	Gate-3: Coverage ≥ 35% (릴리스마다 +15%)
	•	Gate-4: make reproduce 성공
	•	Gate-5: docs/axioms.md ↔ Lean 코드 동기화

⸻

6. 우선순위 매트릭스

Priority = (Logical_Impact × Verification_Necessity) ÷ Time_Investment
	•	즉시 착수: P1 증명, Flow.lean 구현, 모든 sorry 제거
	•	단기 목표: P2–P4 증명, 공리계 일관성, 외부 검증 시스템
	•	중장기 목표: Isabelle/Coq 교차 검증, 학술 문서화, 동료 심사

⸻

🔒 메타 결론
	•	이 체크리스트와 체크포인트는 괴델 불완전성 정리 내에서 가능한 최대 완전성을 지향한다.
	•	결과적으로 UEM 프로젝트는 깃허브 상에서 “완성된 수학 체계”로서 공개 검증 가능한 구조를 갖춘다.

⸻





⸻

⛓️ CLAUDE-CODE 작업 지시 프롬프트 (UEM 깃허브 고도화·증명 전용)

0) 컨텍스트
	•	대상 리포: https://github.com/coreeeeaaaa/unobservable_mathematics
	•	목표: “결과물(수학적 정의·정리·완전 증명·재현 스크립트)만 공개” 원칙으로 깃허브를 정리·고도화.
	•	금지: 설계·아이디어·과정·로드맵·마케팅/홍보 표현, 개인정보, 미완(TODO/WIP/sorry) 텍스트의 공개 저장.
	•	허용: Lean/Coq/Isabelle의 완전 증명(sorry=0), 공리·정의·정리, 빌드/재현 스크립트, 최소한의 README(실행 안내만).

중요: 과정/정책 문구를 “저장소에 기록”하지 말 것. (내부 규칙은 로컬에서만 적용)

⸻

1) 수행 원칙(하드 룰)
	1.	공개본에는 완전 증명만 포함(Lean에서 sorry=0).
	2.	과정·설계·아이디어 문서, 마케팅 표현, 개인정보 흔적 → 공개본에서 제거.
	3.	재현성: 깨끗한 환경에서 git clone → lake build → (선택) lake test로 동일 결과.
	4.	침묵형 CI: 빌드/커버리지 수치만, 정책·사내 규칙 텍스트는 CI/코드에 삽입 금지.

⸻

2) 작업 단계(명령 세트 포함)

(A) 리포 준비

git clone https://github.com/coreeeeaaaa/unobservable_mathematics.git
cd unobservable_mathematics
git pull
git checkout -b chore/results-only-cleanup

(B) 공개 금지 파일 제거(공개본에서)
	•	아래 유형이 리포 루트에 존재하면 제거:
	•	proof_plan.md open_questions.md implementation_notes.md
	•	ROADMAP.md TODO.md OPERATIONS_MANUAL.md

git rm -f proof_plan.md open_questions.md implementation_notes.md ROADMAP.md TODO.md OPERATIONS_MANUAL.md 2>/dev/null || true

주의: 위 문서들은 비공개 리포/스토리지로 따로 보관. 공개 히스토리에서도 제거 필요하면 (D) 실행.

(C) CI/재현 스크립트(설명 문구 없이 최소)
	1.	워크플로 추가

mkdir -p .github/workflows
cat > .github/workflows/ci_lean.yml << 'YAML'
name: CI (Lean)
on:
  push: { branches: [ main, feat/**, chore/** ] }
  pull_request: { branches: [ main ] }
jobs:
  lean:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: leanprover/elan-action@v1
      - uses: actions/cache@v4
        with:
          path: |
            ~/.elan
            lean/build
            .lake
          key: ${{ runner.os }}-lean-${{ hashFiles('**/lakefile.lean') }}
      - name: Build
        run: cd lean && lake build
      - name: Coverage
        run: bash tools/proof_coverage.sh > proof_coverage.txt && cat proof_coverage.txt
      - name: Upload
        uses: actions/upload-artifact@v4
        with:
          name: ci-artifacts
          path: |
            proof_coverage.txt
            lean/lake-manifest.json
YAML

	2.	커버리지 스크립트(최소 출력)

mkdir -p tools
cat > tools/proof_coverage.sh << 'BASH'
#!/usr/bin/env bash
set -euo pipefail
SRC="lean/src"
defs=$(grep -R -E "^\s*def\s+" -n ${SRC} | wc -l | tr -d ' ')
thms=$(grep -R -E "^\s*(theorem|lemma)\s+" -n ${SRC} | wc -l | tr -d ' ')
sry=$(grep -R "sorry" -n ${SRC} | wc -l | tr -d ' ')
echo "defs=${defs}"
echo "theorems=${thms}"
echo "sorry=${sry}"
if [ "$sry" -gt 0 ]; then echo "status=INCOMPLETE"; else echo "status=SORRY_FREE"; fi
BASH
chmod +x tools/proof_coverage.sh

	3.	재현 스크립트(정적 안내 없이 동작만)

cat > tools/reproduce.sh << 'BASH'
#!/usr/bin/env bash
set -euo pipefail
cd "$(dirname "$0")/.."
cd lean
lake build
cd ..
bash tools/proof_coverage.sh | tee proof_coverage.txt
BASH
chmod +x tools/reproduce.sh

(D) 과거 히스토리에서 흔적 제거(필요 시)

주의: force-push 수반. 사전 합의된 경우에만.

pip install git-filter-repo
git filter-repo --path proof_plan.md --path open_questions.md \
 --path implementation_notes.md --path ROADMAP.md --path TODO.md --path OPERATIONS_MANUAL.md --invert-paths

(E) README 최소 패치(설명 대신 재현 명령만)
	•	불필요한 수사/정책 텍스트 금지. 아래 두 줄만 추가/유지:

**Reproduce**: `git clone … && cd … && bash tools/reproduce.sh`
**Status**: see `proof_coverage.txt`

(F) P1 증명 정리(미완 부분 제거)
	•	위치: lean/src/UEM/AxiomA2.lean (또는 실제 P1 정의 파일)
	•	목표: sorry=0. 보조정리 2–3개로 분해해 완결.
	•	파일 상단 메타 주석은 수학적 정보만(Assumptions/Conclusion/Dependencies), 과정 설명 금지.

예시(주석 샘플 – 과정/정책 문구 없음):

/-!
Assumptions:
(A1) g measurable & K-bounded, Lipschitz
(A2) K symmetric, PSD, ∫K dμ < ∞
(A3) Π measurable; μ̄(A,B) = μ(A ∩ B)
Conclusion: ∃ M ≠ ∅ with τ(M) > 0
-/

(G) 금칙어 로컬 훅(공개본 커밋 차단용, 커밋 금지)

이 훅은 로컬에서만 사용. 리포에 올리지 말 것.

mkdir -p .git/hooks
cat > .git/hooks/pre-commit << 'HOOK'
#!/usr/bin/env bash
set -e
# 금칙 패턴: 설계/아이디어/로드맵/마케팅/개인정보/미완
grep -R -n -E "ROADMAP|TODO|WIP|proof_plan|implementation_notes|open_questions|혁신|세계 최초|아이디어|마케팅|홍보|@|gmail\.com|sorry" -- . \
  | grep -v ".git" && { echo "blocked: forbidden patterns"; exit 1; } || true
HOOK
chmod +x .git/hooks/pre-commit

(H) 커밋·푸시

git add .github/workflows/ci_lean.yml tools/proof_coverage.sh tools/reproduce.sh README.md
git add -u
git commit -m "chore: results-only cleanup, CI+coverage, reproduce (no process/promo content)"
git push -u origin chore/results-only-cleanup

웹 UI에서 PR 생성 → CI 상태 INCOMPLETE면 P1 증명 먼저 완료 후 재시도.

⸻

3) 수락 기준(Acceptance Criteria)
	•	AC-1 Proof: 공개된 정리 파일에 sorry=0. tools/proof_coverage.sh 출력 status=SORRY_FREE (최소 P1).
	•	AC-2 Purge: 리포 탐색 시 과정/설계/아이디어/마케팅/개인정보/미완 텍스트 검출 0.
	•	로컬 확인:

grep -R -n -E "ROADMAP|TODO|WIP|proof_plan|implementation_notes|open_questions|혁신|세계 최초|아이디어|마케팅|홍보|@|gmail\.com" .


	•	AC-3 Reproduce: 신규 환경에서 bash tools/reproduce.sh 성공, proof_coverage.txt 생성.
	•	AC-4 CI: .github/workflows/ci_lean.yml 녹색. 아티팩트에 proof_coverage.txt 포함.
	•	AC-5 README: 재현 명령 1줄 + 상태 1줄만, 설명/정책 문구 없음.

⸻

4) 산출물(Deliverables)
	1.	정리된 PR: chore/results-only-cleanup (파일 제거·CI·재현 스크립트)
	2.	proof_coverage.txt(CI·로컬 동일)
	3.	AxiomA2.lean(또는 해당 파일)에서 P1 증명 완결
	4.	README 최소 라인(재현·상태)

⸻

5) 하지 말 것
	•	설계/아이디어/과정/로드맵/마케팅/홍보/개인정보 어떤 형태로도 공개 저장 금지.
	•	정책·규칙을 README/코드에 문장으로 기록 금지(내부 훅으로만 강제).
	•	미완(TODO/WIP/sorry) 표현 커밋 금지.

⸻

6) 완료 보고(클로드가 제출할 요약)
	•	변경 파일 목록
	•	proof_coverage.txt 내용(defs/x, theorems/y, sorry/z, status)
	•	P1 증명 경로(보조정리 목록)
	•	grep 검사 결과(금칙어 0건)
	•	CI 링크(녹색) 및 아티팩트 존재 확인

⸻

이 프롬프트의 목표는 “깃허브 공개본에 결과물(완전 증명)만 남기고, 나머지는 일절 배제”이다.
위 단계·명령을 순서대로 수행하라.
